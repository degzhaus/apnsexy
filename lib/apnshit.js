// Generated by CoffeeScript 1.4.0
(function() {
  var Apnshit, Feedback, Notification, key, value, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ref = require('./apnshit/common');
  for (key in _ref) {
    value = _ref[key];
    eval("var " + key + " = value;");
  }

  Feedback = require('./apnshit/feedback');

  Notification = require('./apnshit/notification');

  Apnshit = (function(_super) {

    __extends(Apnshit, _super);

    function Apnshit(options) {
      this.watchForStaleSocket = __bind(this.watchForStaleSocket, this);

      var _this = this;
      this.on("error", function() {});
      this.options = {
        ca: null,
        cert: 'cert.pem',
        debug: false,
        debug_ignore: [],
        enhanced: true,
        gateway: 'gateway.push.apple.com',
        infinite_resend_limit: 10,
        key: 'key.pem',
        passphrase: null,
        port: 2195,
        resend_on_drop: true,
        timeout: 2000,
        reject_unauthorized: true
      };
      _.extend(this.options, options);
      if (this.options.debug) {
        _.each(this.events, function(e) {
          return _this.on(e, function(a, b) {
            if (_this.options.debug_ignore.indexOf(e) >= 0) {
              return;
            }
            if (e === 'send#write') {
              return _this.emit('debug', e, a.alert);
            } else if (e === 'socketData#invalid_token#notification') {
              return _this.emit('debug', e, a.alert);
            } else if (e === "disconnect#drop#resend") {
              return _this.emit('debug', e, a.length);
            } else if (e === "socketData#start") {
              return _this.emit('debug', e, a[0]);
            } else if (e === "socket#error") {
              return _this.emit('debug', e, a);
            } else {
              return _this.emit('debug', e);
            }
          });
        });
      }
      this.reset({
        socket: false
      });
    }

    Apnshit.prototype.connect = function() {
      var _this = this;
      this.emit('connect#start', this.connect_promise);
      return this.connect_promise || (this.connect_promise = defer(function(resolve, reject) {
        var socket_options;
        if (_this.socket && _this.socket.writable) {
          _this.emit('connect#exists');
          return resolve();
        } else {
          _this.emit('connect#connecting');
          socket_options = {
            ca: _this.options.ca,
            cert: fs.readFileSync(_this.options.cert),
            key: fs.readFileSync(_this.options.key),
            passphrase: _this.options.passphrase,
            rejectUnauthorized: _this.options.reject_unauthorized,
            socket: new net.Stream()
          };
          _this.socket = tls.connect(_this.options.port, _this.options.gateway, socket_options, function() {
            resolve();
            delete _this.connect_promise;
            _this.emit("connect#connected");
            return _this.watchForStaleSocket();
          });
          _this.socket.on("close", function(data) {
            return console.log("CLOSE");
          });
          _this.socket.on("data", function(data) {
            return _this.socketData(data);
          });
          _this.socket.on("drain", function(data) {
            return console.log("DRAIN");
          });
          _this.socket.on("error", function(e) {
            return _this.emit("socket#error", e);
          });
          _this.socket.setNoDelay(false);
          return _this.socket.socket.connect(_this.options.port, _this.options.gateway);
        }
      }));
    };

    Apnshit.prototype.events = ['connect#start', 'connect#exists', 'connect#connecting', 'connect#connected', 'disconnect#start', 'disconnect#drop', 'disconnect#drop#infinite_resend', 'disconnect#drop#infinite_resend#limit_reached', 'disconnect#drop#resend', 'disconnect#drop#nothing_to_resend', 'disconnect#finish', 'send#start', 'send#connected', 'send#write', 'send#write#finish', 'socket#error', 'socketData#start', 'socketData#found_intentional_bad_notification', 'socketData#found_notification', 'watchForStaleSocket#start', 'watchForStaleSocket#interval_start', 'watchForStaleSocket#stale', 'watchForStaleSocket#stale#no_response', 'watchForStaleSocket#stale#intentional_bad_notification'];

    Apnshit.prototype.disconnect = function(options) {
      var _this = this;
      if (options == null) {
        options = {};
      }
      this.emit("disconnect#start", options);
      if (options.drop) {
        return this.reset({
          socket: true
        }).then(function() {
          var resend, resend_uids;
          _this.emit("disconnect#drop", _this.not_sure_if_sent);
          if (options.resend) {
            resend = options.resend && options.resend.length;
          } else {
            resend = _this.options.resend_on_drop && _this.not_sure_if_sent && _this.not_sure_if_sent.length;
          }
          if (resend) {
            resend = options.resend || _this.not_sure_if_sent.slice();
            _this.not_sure_if_sent = [];
            _this.last_resend_uids || (_this.last_resend_uids = []);
            resend_uids = _.map(resend, function(n) {
              return n._last_uid || false;
            });
            console.log('resend');
            if (!(resend_uids < _this.last_resend_uids || _this.last_resend_uids < resend_uids)) {
              _this.emit("disconnect#drop#infinite_resend", resend);
              _this.infinite_resend_count || (_this.infinite_resend_count = 0);
              _this.infinite_resend_count++;
              if (_this.infinite_resend_count === _this.options.infinite_resend_limit) {
                _this.emit("disconnect#drop#infinite_resend#limit_reached", resend);
                _this.emit("dropped", resend);
                delete _this.last_resend_uids;
                return;
              }
            } else {
              _this.infinite_resend_count = 0;
            }
            _this.emit("disconnect#drop#resend", resend);
            _this.last_resend_uids = _.map(resend, function(n) {
              return n._uid;
            });
            return setTimeout(function() {
              var item, _i, _len, _results;
              _results = [];
              for (_i = 0, _len = resend.length; _i < _len; _i++) {
                item = resend[_i];
                _results.push(_this.send(item));
              }
              return _results;
            }, 500 * _this.infinite_resend_count);
          } else {
            _this.not_sure_if_sent = [];
            _this.emit("disconnect#drop#nothing_to_resend");
            return _this.emit("finish");
          }
        });
      } else {
        this.emit("disconnect#finish");
        return this.emit("finish");
      }
    };

    Apnshit.prototype.reset = function(options) {
      var _this = this;
      if (options == null) {
        options = {};
      }
      return defer(function(resolve, reject) {
        console.log('reset');
        _this.write_promise = defer(function(resolve, reject) {
          return resolve();
        });
        delete _this.bad_alert_sent;
        delete _this.bytes_read;
        delete _this.bytes_written;
        delete _this.stale_count;
        if (_this.interval) {
          clearInterval(_this.interval);
        }
        if (options.socket) {
          delete _this.connect_promise;
          if (_this.socket) {
            _this.socket.once('close', function() {
              delete _this.socket;
              return resolve();
            });
            return _this.socket.end();
          } else {
            return resolve();
          }
        } else {
          return resolve();
        }
      });
    };

    Apnshit.prototype.send = function(notification) {
      var data, encoding, message, message_length, position, token,
        _this = this;
      this.emit("send#start", notification);
      this.current_id || (this.current_id = 0);
      this.not_sure_if_sent || (this.not_sure_if_sent = []);
      data = void 0;
      encoding = notification.encoding || "utf8";
      message = JSON.stringify(notification);
      message_length = Buffer.byteLength(message, encoding);
      position = 0;
      token = new Buffer(notification.device.replace(/\s/g, ""), "hex");
      return this.connect().then(function() {
        _this.emit("send#connected", notification);
        notification._last_uid = notification._uid;
        notification._uid = _this.current_id++;
        if (_this.current_id > 0xffffffff) {
          _this.current_id = 0;
        }
        if (_this.options.enhanced) {
          data = new Buffer(1 + 4 + 4 + 2 + token.length + 2 + message_length);
          data[position] = 1;
          position++;
          data.writeUInt32BE(notification._uid, position);
          position += 4;
          data.writeUInt32BE(notification.expiry, position);
          position += 4;
        } else {
          data = new Buffer(1 + 2 + token.length + 2 + message_length);
          data[position] = 0;
          position++;
        }
        data.writeUInt16BE(token.length, position);
        position += 2;
        position += token.copy(data, position, 0);
        data.writeUInt16BE(message_length, position);
        position += 2;
        position += data.write(message, position, encoding);
        if (notification.alert !== 'x') {
          _this.not_sure_if_sent.push(notification);
        }
        return _this.write_promise.then(function() {
          return defer(function(resolve, reject) {
            _this.emit('send#write', notification);
            return _this.socket.write(data, encoding, function() {
              _this.emit('send#write#finish', notification);
              return resolve(notification);
            });
          });
        });
      });
    };

    Apnshit.prototype.socketData = function(data) {
      var error_code, identifier, notification, resend,
        _this = this;
      this.emit('socketData#start', data);
      error_code = data[0];
      identifier = data.readUInt32BE(2);
      notification = _.find(this.not_sure_if_sent, function(item, i) {
        return item._uid === identifier;
      });
      if (notification) {
        if (notification.alert === 'x') {
          this.emit('socketData#found_intentional_bad_notification');
          return this.disconnect();
        } else {
          this.emit('socketData#found_notification', notification);
          if (error_code === 8) {
            this.emit('error', notification);
          }
          resend = this.not_sure_if_sent.slice(this.not_sure_if_sent.indexOf(notification) + 1);
          return this.disconnect({
            drop: true,
            resend: resend,
            socket: true
          });
        }
      }
    };

    Apnshit.prototype.watchForStaleSocket = function() {
      var _this = this;
      this.emit('watchForStaleSocket#start');
      if (this.interval) {
        clearInterval(this.interval);
      }
      return this.interval = setInterval(function() {
        var noti, stale;
        _this.emit('watchForStaleSocket#interval_start');
        console.log("@socket && !@socket.writable", _this.socket && !_this.socket.writable);
        if (_this.socket && !_this.socket.writable) {
          _this.disconnect({
            drop: true
          });
          return;
        }
        if (!(_this.socket && _this.socket.writable)) {
          return;
        }
        stale = _this.socket.bytesRead === _this.bytes_read && _this.socket.bytesWritten === _this.bytes_written;
        _this.emit('watchForStaleSocket#stale', stale);
        if (stale) {
          _this.stale_count || (_this.stale_count = 0);
          _this.stale_count++;
          if (_this.bad_alert_sent) {
            _this.emit('watchForStaleSocket#stale#no_response');
            _this.disconnect({
              drop: true
            });
          } else if (_this.stale_count === 2) {
            _this.emit('watchForStaleSocket#stale#intentional_bad_notification');
            noti = new Notification();
            noti.alert = "x";
            noti.badge = 0;
            noti.sound = "default";
            noti.device = Array(32).join("a0");
            _this.bad_alert_sent = true;
            _this.send(noti);
          }
        }
        if (_this.socket) {
          _this.bytes_read = _this.socket.bytesRead;
          return _this.bytes_written = _this.socket.bytesWritten;
        } else {
          delete _this.bytes_read;
          return delete _this.bytes_written;
        }
      }, this.options.timeout);
    };

    return Apnshit;

  })(EventEmitter);

  module.exports = {
    Apnshit: Apnshit,
    Feedback: Feedback,
    Notification: Notification
  };

}).call(this);
