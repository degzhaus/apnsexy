// Generated by CoffeeScript 1.4.0
(function() {
  var Apnshit, key, value, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ref = require('./apnshit/common');
  for (key in _ref) {
    value = _ref[key];
    eval("var " + key + " = value;");
  }

  module.exports = Apnshit = (function(_super) {

    __extends(Apnshit, _super);

    function Apnshit(options) {
      this.watchForStaleSocket = __bind(this.watchForStaleSocket, this);

      var _this = this;
      this.Notification = require('./apnshit/notification');
      this.on("error", function() {});
      this.options = {
        ca: null,
        cert: 'cert.pem',
        debug: false,
        debug_ignore: [],
        enhanced: true,
        gateway: 'gateway.push.apple.com',
        key: 'key.pem',
        passphrase: null,
        port: 2195,
        resend_on_drop: false,
        timeout: 2000,
        reject_unauthorized: true
      };
      _.extend(this.options, options);
      if (this.options.debug) {
        _.each(this.events, function(e) {
          return _this.on(e, function(a, b) {
            if (_this.options.debug_ignore.indexOf(e) >= 0) {
              return;
            }
            if (e === 'send#write') {
              return _this.emit('debug', e, a.alert);
            } else if (e === 'socketData#invalid_token#notification') {
              return _this.emit('debug', e, a.alert);
            } else if (e === "disconnect#drop#resend") {
              return _this.emit('debug', e, a.length);
            } else if (e === "socketData#start") {
              return _this.emit('debug', e, a[0]);
            } else {
              return _this.emit('debug', e);
            }
          });
        });
      }
    }

    Apnshit.prototype.connect = function() {
      var _this = this;
      this.emit('connect#start', this.connect_promise);
      return this.connect_promise || (this.connect_promise = this.defer(function(resolve, reject) {
        var socket_options;
        if (_this.socket && _this.socket.writable) {
          _this.emit('connect#exists');
          return resolve();
        } else {
          _this.emit('connect#connecting');
          _this.connecting = true;
          socket_options = {
            ca: _this.options.ca,
            cert: fs.readFileSync(_this.options.cert),
            key: fs.readFileSync(_this.options.key),
            passphrase: _this.options.passphrase,
            rejectUnauthorized: _this.options.reject_unauthorized,
            socket: new net.Stream()
          };
          _this.socket = tls.connect(_this.options.port, _this.options.gateway, socket_options, function() {
            resolve();
            delete _this.connect_promise;
            _this.emit("connect#connected");
            return _this.watchForStaleSocket();
          });
          _this.socket.on("data", function(data) {
            return _this.socketData(data);
          });
          _this.socket.on("error", function(e) {
            _this.emit("socket#error", e);
            return _this.disconnect({
              drop: true
            });
          });
          return _this.socket.socket.connect(_this.options.port, _this.options.gateway);
        }
      }));
    };

    Apnshit.prototype.defer = function(fn) {
      var d;
      d = Q.defer();
      fn(d.resolve, d.reject);
      return d.promise;
    };

    Apnshit.prototype.events = ['connect#start', 'connect#exists', 'connect#connecting', 'connect#connected', 'disconnect#start', 'disconnect#drop', 'disconnect#drop#resend', 'disconnect#drop#nothing_to_resend', 'disconnect#finish', 'send#start', 'send#connected', 'send#write', 'send#write#finish', 'socket#error', 'socketData#start', 'socketData#found_intentional_bad_notification', 'socketData#found_notification', 'watchForStaleSocket#start', 'watchForStaleSocket#interval_start', 'watchForStaleSocket#stale', 'watchForStaleSocket#stale#no_response', 'watchForStaleSocket#stale#intentional_bad_notification'];

    Apnshit.prototype.disconnect = function(options) {
      var item, resend, _i, _len;
      if (options == null) {
        options = {};
      }
      this.emit("disconnect#start", options);
      delete this.bad_alert_sent;
      delete this.bytes_read;
      delete this.bytes_written;
      delete this.connect_promise;
      delete this.stale_count;
      this.socket.destroy();
      delete this.socket;
      if (options.drop) {
        this.emit("disconnect#drop", this.not_sure_if_sent);
        if (options.resend) {
          resend = options.resend && options.resend.length;
        } else {
          resend = this.options.resend_on_drop && this.not_sure_if_sent && this.not_sure_if_sent.length;
        }
        if (resend) {
          resend = options.resend || this.not_sure_if_sent.slice();
          this.not_sure_if_sent = [];
          this.emit("disconnect#drop#resend", resend);
          for (_i = 0, _len = resend.length; _i < _len; _i++) {
            item = resend[_i];
            this.send(item);
          }
        } else {
          this.emit("disconnect#drop#nothing_to_resend");
          this.emit("finish");
        }
      } else {
        this.emit("disconnect#finish");
        this.emit("finish");
        this.not_sure_if_sent = [];
      }
      if (this.interval) {
        return clearInterval(this.interval);
      }
    };

    Apnshit.prototype.send = function(notification) {
      var data, encoding, message, message_length, position, token,
        _this = this;
      this.emit("send#start", notification);
      this.current_id || (this.current_id = 0);
      this.not_sure_if_sent || (this.not_sure_if_sent = []);
      data = void 0;
      encoding = notification.encoding || "utf8";
      message = JSON.stringify(notification);
      message_length = Buffer.byteLength(message, encoding);
      position = 0;
      token = new Buffer(notification.device.replace(/\s/g, ""), "hex");
      return this.connect().then(function() {
        _this.emit("send#connected", notification);
        notification._uid = _this.current_id++;
        if (_this.current_id > 0xffffffff) {
          _this.current_id = 0;
        }
        if (_this.options.enhanced) {
          data = new Buffer(1 + 4 + 4 + 2 + token.length + 2 + message_length);
          data[position] = 1;
          position++;
          data.writeUInt32BE(notification._uid, position);
          position += 4;
          data.writeUInt32BE(notification.expiry, position);
          position += 4;
        } else {
          data = new Buffer(1 + 2 + token.length + 2 + message_length);
          data[position] = 0;
          position++;
        }
        data.writeUInt16BE(token.length, position);
        position += 2;
        position += token.copy(data, position, 0);
        data.writeUInt16BE(message_length, position);
        position += 2;
        position += data.write(message, position, encoding);
        _this.not_sure_if_sent.push(notification);
        return _this.defer(function(resolve, reject) {
          _this.emit('send#write', notification);
          return _this.socket.write(data, encoding, function() {
            _this.emit('send#write#finish', notification);
            return resolve(notification);
          });
        });
      });
    };

    Apnshit.prototype.socketData = function(data) {
      var error_code, identifier, notification, resend,
        _this = this;
      this.emit('socketData#start', data);
      error_code = data[0];
      identifier = data.readUInt32BE(2);
      notification = _.find(this.not_sure_if_sent, function(item, i) {
        return item._uid === identifier;
      });
      if (notification) {
        if (notification.alert === 'x') {
          this.emit('socketData#found_intentional_bad_notification');
          return this.disconnect();
        } else {
          this.emit('socketData#found_notification', notification);
          if (error_code === 8) {
            this.emit('error', notification);
          }
          resend = this.not_sure_if_sent.slice(this.not_sure_if_sent.indexOf(notification) + 1);
          return this.disconnect({
            drop: true,
            resend: resend
          });
        }
      }
    };

    Apnshit.prototype.watchForStaleSocket = function() {
      var _this = this;
      this.emit('watchForStaleSocket#start');
      if (this.interval) {
        clearInterval(this.interval);
      }
      return this.interval = setInterval(function() {
        var noti, stale;
        _this.emit('watchForStaleSocket#interval_start');
        if (_this.socket && !_this.socket.writable) {
          _this.disconnect({
            drop: true
          });
          return;
        }
        if (!(_this.socket && _this.socket.writable)) {
          return;
        }
        stale = _this.socket.bytesRead === _this.bytes_read && _this.socket.bytesWritten === _this.bytes_written;
        _this.emit('watchForStaleSocket#stale', stale);
        if (stale) {
          _this.stale_count || (_this.stale_count = 0);
          _this.stale_count += 1;
          if (_this.bad_alert_sent) {
            _this.emit('watchForStaleSocket#stale#no_response');
            _this.disconnect({
              drop: true
            });
          } else if (_this.stale_count === 2) {
            _this.emit('watchForStaleSocket#stale#intentional_bad_notification');
            noti = new _this.Notification();
            noti.alert = "x";
            noti.badge = 0;
            noti.sound = "default";
            noti.device = Array(32).join("a0");
            _this.bad_alert_sent = true;
            _this.send(noti);
          }
        }
        if (_this.socket) {
          _this.bytes_read = _this.socket.bytesRead;
          return _this.bytes_written = _this.socket.bytesWritten;
        } else {
          delete _this.bytes_read;
          return delete _this.bytes_written;
        }
      }, this.options.timeout);
    };

    return Apnshit;

  })(EventEmitter);

}).call(this);
