// Generated by CoffeeScript 1.4.0
(function() {
  var Apnshit, Debug, Feedback, Librato, Notification, key, value, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ref = require('./apnshit/common');
  for (key in _ref) {
    value = _ref[key];
    eval("var " + key + " = value;");
  }

  Debug = require('./apnshit/debug');

  Feedback = require('./apnshit/feedback');

  Librato = require('./apnshit/librato');

  Notification = require('./apnshit/notification');

  Apnshit = (function(_super) {

    __extends(Apnshit, _super);

    function Apnshit(options) {
      this.options = _.extend({
        ca: null,
        cert: 'cert.pem',
        debug: false,
        debug_ignore: [],
        gateway: 'gateway.push.apple.com',
        key: 'key.pem',
        librato: null,
        passphrase: null,
        port: 2195,
        secure_cert: true,
        timeout: 2000
      }, options);
      this.on('error', function() {});
      if (this.options.debug) {
        new Debug(this);
      }
      if (this.options.librato) {
        new Librato(this);
      }
      this.resetVars();
      this.keepSending();
    }

    Apnshit.prototype.checkForStaleConnection = function() {
      var potential_drops, total_sent;
      this.debug('checkForStaleConnection#start');
      this.stale_count || (this.stale_count = 0);
      if (!(this.stale_index != null) || this.stale_index < this.sent_index) {
        this.stale_index = this.sent_index;
        this.stale_count = 0;
      }
      if (this.stale_index === this.sent_index) {
        this.stale_count++;
      }
      if (this.stale_count >= 2) {
        clearInterval(this.stale_connection_timer);
        this.potential_drops += this.notifications.length - 1 - this.sent_index;
        this.debug('checkForStaleConnection#@potential_drops', this.potential_drops);
        total_sent = this.sent_index + 1;
        potential_drops = this.potential_drops;
        this.killSocket();
        this.resetVars();
        this.debug('checkForStaleConnection#stale');
        return this.emit('finish', this.sent_index + 1, this.potential_drops);
      }
    };

    Apnshit.prototype.connect = function() {
      var _this = this;
      this.debug('connect#start');
      if (!this.connecting && (!this.socket || !this.socket.writable)) {
        delete this.connect_promise;
        this.connect_index = this.index - 1;
      }
      return this.connect_promise || (this.connect_promise = defer(function(resolve, reject) {
        var socket_options;
        if (_this.socket && _this.socket.writable) {
          _this.debug('connect#exists');
          return resolve();
        } else {
          _this.debug('connect#connecting');
          _this.resetVars({
            connecting: true
          });
          _this.connecting = true;
          socket_options = {
            ca: _this.options.ca,
            cert: fs.readFileSync(_this.options.cert),
            key: fs.readFileSync(_this.options.key),
            passphrase: _this.options.passphrase,
            rejectUnauthorized: _this.options.secure_cert,
            socket: new net.Stream()
          };
          return setTimeout(function() {
            _this.socket = tls.connect(_this.options.port, _this.options.gateway, socket_options, function() {
              _this.debug("connect#connected");
              _this.connecting = false;
              return resolve();
            });
            _this.socket.on("close", function() {
              return _this.socketError();
            });
            _this.socket.on("data", function(data) {
              return _this.socketData(data);
            });
            _this.socket.on("error", function(e) {
              return _this.socketError(e);
            });
            _this.socket.setNoDelay(false);
            return _this.socket.socket.connect(_this.options.port, _this.options.gateway);
          }, 10);
        }
      }));
    };

    Apnshit.prototype.enqueue = function(notification) {
      var _this = this;
      this.debug("enqueue", notification);
      if (this.uid > 0xffffffff) {
        this.uid = 0;
      }
      notification._uid = this.uid++;
      this.notifications.push(notification);
      return this.stale_connection_timer || (this.stale_connection_timer = setInterval(function() {
        return _this.checkForStaleConnection();
      }, this.options.timeout));
    };

    Apnshit.prototype.keepSending = function() {
      var _this = this;
      return process.nextTick(function() {
        _this.debug("keepSending");
        if (_this.error_index != null) {
          _this.index = _this.error_index + 1;
          delete _this.error_index;
        }
        if (_this.index !== _this.notifications.length) {
          _this.send();
        }
        return _this.keepSending();
      });
    };

    Apnshit.prototype.killSocket = function() {
      delete this.connecting;
      this.socket.removeAllListeners();
      return this.socket.writable = false;
    };

    Apnshit.prototype.resetVars = function(options) {
      if (options == null) {
        options = {};
      }
      if (options.connecting == null) {
        delete this.connecting;
        delete this.error_index;
        delete this.stale_connection_timer;
        this.index = 0;
        this.potential_drops = 0;
        this.notifications = [];
        this.sent_index = 0;
        this.uid = 0;
      }
      delete this.stale_count;
      return delete this.stale_index;
    };

    Apnshit.prototype.send = function() {
      var index, notification,
        _this = this;
      notification = this.notifications[this.index];
      if (notification) {
        this.debug('send#@index', this.index);
        index = this.index;
        this.index++;
        this.debug("send#start", notification);
        return this.connect().then(function() {
          _this.debug("send#write", notification);
          if (_this.socket.writable) {
            return _this.socket.write(notification.data(), notification.encoding, function() {
              _this.debug("send#written", notification);
              _this.emit("sent", notification);
              return _this.sent_index = index;
            });
          }
        });
      }
    };

    Apnshit.prototype.socketData = function(data) {
      var error_code, identifier, notification,
        _this = this;
      error_code = data[0];
      identifier = data.readUInt32BE(2);
      this.debug('socketData#start', {
        error_code: error_code,
        identifier: identifier
      });
      delete this.error_index;
      _.each(this.notifications, function(item, i) {
        if (item._uid === identifier) {
          return _this.error_index = i;
        }
      });
      if (this.error_index != null) {
        this.debug('socketData#@error_index', this.error_index);
        notification = this.notifications[this.error_index];
        this.debug('socketData#found_notification', identifier, notification);
        if (error_code === 8) {
          this.emit('error', notification);
        }
        return this.killSocket();
      }
    };

    Apnshit.prototype.socketError = function(e) {
      this.debug('socketError#start', e);
      if (this.error_index == null) {
        this.error_index = this.sent_index + 1;
        this.debug('socketError#@error_index', this.error_index);
        this.potential_drops += this.error_index - this.connect_index;
        this.debug('socketError#@connect_index', this.connect_index);
        this.debug('socketError#@potential_drops', this.potential_drops);
      }
      return this.killSocket();
    };

    return Apnshit;

  })(EventEmitter);

  module.exports = {
    Apnshit: Apnshit,
    Feedback: Feedback,
    Notification: Notification
  };

}).call(this);
