// Generated by CoffeeScript 1.4.0
(function() {
  var Apnshit, key, value, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ref = require('./apnshit/common');
  for (key in _ref) {
    value = _ref[key];
    eval("var " + key + " = value;");
  }

  module.exports = Apnshit = (function(_super) {

    __extends(Apnshit, _super);

    function Apnshit(options) {
      this.watchForStaleSocket = __bind(this.watchForStaleSocket, this);
      this.Notification = require('./apnshit/notification');
      this.on("error", function() {});
      this.options = {
        ca: null,
        cert: 'cert.pem',
        enhanced: true,
        gateway: 'gateway.push.apple.com',
        key: 'key.pem',
        passphrase: null,
        port: 2195,
        resend_on_drop: false,
        timeout: 5000,
        rejectUnauthorized: true
      };
      _.extend(this.options, options);
    }

    Apnshit.prototype.connect = function() {
      var _this = this;
      console.log('connect @connect_promise', this.connect_promise);
      return this.connect_promise || (this.connect_promise = this.defer(function(resolve, reject) {
        var socket_options;
        if (_this.socket && _this.socket.writable) {
          console.log('connection exists');
          return resolve();
        } else {
          console.log('connecting!');
          _this.connecting = true;
          socket_options = {
            ca: _this.options.ca,
            cert: fs.readFileSync(_this.options.cert),
            key: fs.readFileSync(_this.options.key),
            passphrase: _this.options.passphrase,
            rejectUnauthorized: _this.options.rejectUnauthorized,
            socket: new net.Stream()
          };
          _this.socket = tls.connect(_this.options.port, _this.options.gateway, socket_options, function() {
            resolve();
            delete _this.connect_promise;
            _this.emit("connect");
            _this.watchForStaleSocket();
            return console.log('connected!');
          });
          _this.socket.on("end", function() {
            return _this.socketEnd;
          });
          _this.socket.on("error", function() {
            return _this.socketError;
          });
          _this.socket.on("timeout", function() {
            return _this.socketTimeout;
          });
          _this.socket.on("data", function(data) {
            return _this.socketData(data);
          });
          _this.socket.on("drain", function() {
            return _this.socketDrain;
          });
          _this.socket.on("clientError", function() {
            return _this.socketClientError;
          });
          _this.socket.on("close", function() {
            return _this.socketClose;
          });
          _this.socket.setNoDelay(false);
          return _this.socket.socket.connect(_this.options.port, _this.options.gateway);
        }
      }));
    };

    Apnshit.prototype.defer = function(fn) {
      var d;
      d = Q.defer();
      fn(d.resolve, d.reject);
      return d.promise;
    };

    Apnshit.prototype.disconnect = function(options) {
      var drop, item, resend, _i, _len;
      if (options == null) {
        options = {};
      }
      console.log('disconnect');
      delete this.bad_alert_sent;
      delete this.bytes_read;
      delete this.bytes_written;
      delete this.connect_promise;
      this.socket.destroy();
      delete this.socket;
      if (options.drop) {
        drop = this.options.resend_on_drop && this.not_sure_if_sent && this.not_sure_if_sent.length;
        console.log("drop @not_sure_if_sent.length", this.not_sure_if_sent.length ? this.not_sure_if_sent.length : 0);
        if (drop) {
          resend = this.not_sure_if_sent.slice();
          this.not_sure_if_sent = [];
          console.log('drop resend', this.inspect(resend));
          console.log('drop resend.length', resend.length);
          for (_i = 0, _len = resend.length; _i < _len; _i++) {
            item = resend[_i];
            this.send(item);
          }
        } else {
          this.emit('done');
        }
      } else {
        this.not_sure_if_sent = [];
      }
      if (this.interval) {
        return clearInterval(this.interval);
      }
    };

    Apnshit.prototype.send = function(notification) {
      var data, encoding, message, message_length, position, token,
        _this = this;
      this.current_id || (this.current_id = 0);
      this.not_sure_if_sent || (this.not_sure_if_sent = []);
      data = void 0;
      encoding = notification.encoding || "utf8";
      message = JSON.stringify(notification);
      message_length = Buffer.byteLength(message, encoding);
      position = 0;
      token = new Buffer(notification.device.replace(/\s/g, ""), "hex");
      return this.connect().then(function() {
        notification._uid = _this.current_id++;
        if (_this.current_id > 0xffffffff) {
          _this.current_id = 0;
        }
        if (_this.options.enhanced) {
          data = new Buffer(1 + 4 + 4 + 2 + token.length + 2 + message_length);
          data[position] = 1;
          position++;
          data.writeUInt32BE(notification._uid, position);
          position += 4;
          data.writeUInt32BE(notification.expiry, position);
          position += 4;
        } else {
          data = new Buffer(1 + 2 + token.length + 2 + message_length);
          data[position] = 0;
          position++;
        }
        data.writeUInt16BE(token.length, position);
        position += 2;
        position += token.copy(data, position, 0);
        data.writeUInt16BE(message_length, position);
        position += 2;
        position += data.write(message, position, encoding);
        _this.not_sure_if_sent.push(notification);
        return _this.defer(function(resolve, reject) {
          console.log('write', notification.alert);
          return _this.socket.write(data, encoding, function() {
            return resolve(notification);
          });
        });
      });
    };

    Apnshit.prototype.socketData = function(data) {
      var error_code, identifier, item, notification, resend, _i, _len, _results,
        _this = this;
      console.log('socketData', data[0]);
      if (data[0] === 8) {
        error_code = data[1];
        identifier = data.readUInt32BE(2);
        notification = _.find(this.not_sure_if_sent, function(item, i) {
          return item._uid === identifier;
        });
        if (notification) {
          if (notification.alert === 'x') {
            return this.emit('done');
          } else {
            console.log('error', notification.alert);
            this.emit('error', notification);
            resend = this.not_sure_if_sent.slice(this.not_sure_if_sent.indexOf(notification) + 1);
            this.disconnect({
              drop: this.bad_alert_sent
            });
            console.log('resend', this.inspect(resend));
            console.log('resend.length', resend.length);
            _results = [];
            for (_i = 0, _len = resend.length; _i < _len; _i++) {
              item = resend[_i];
              _results.push(this.send(item));
            }
            return _results;
          }
        }
      }
    };

    Apnshit.prototype.inspect = function(arr) {
      var output;
      output = _.map(arr, function(item) {
        return item.alert;
      });
      return "[ " + (output.join(',')) + " ]";
    };

    Apnshit.prototype.socketDrain = function() {
      return console.log('socket drain');
    };

    Apnshit.prototype.socketEnd = function() {
      console.log('socket end');
      return this.disconnect();
    };

    Apnshit.prototype.socketError = function() {
      console.log('socket error');
      return this.disconnect();
    };

    Apnshit.prototype.socketClientError = function() {
      console.log('socket client error');
      return this.disconnect();
    };

    Apnshit.prototype.socketClose = function() {
      console.log('socket close');
      return this.disconnect();
    };

    Apnshit.prototype.socketTimeout = function() {
      console.log('socket timeout');
      return this.disconnect();
    };

    Apnshit.prototype.watchForStaleSocket = function() {
      var _this = this;
      console.log('watchForStaleSocket');
      if (this.interval) {
        clearInterval(this.interval);
      }
      return this.interval = setInterval(function() {
        var noti, stale;
        console.log('setInterval');
        console.log('socket?', _this.socket ? 'true' : 'false');
        if (_this.socket) {
          console.log("@socket.writable", _this.socket.writable);
        }
        if (_this.socket && !_this.socket.writable) {
          _this.disconnect({
            drop: true
          });
          return;
        }
        if (!(_this.socket && _this.socket.writable)) {
          return;
        }
        stale = _this.socket.bytesRead === _this.bytes_read && _this.socket.bytesWritten === _this.bytes_written;
        console.log("stale", stale);
        if (stale) {
          if (_this.bad_alert_sent) {
            console.log("bad alert not responded to");
            _this.disconnect({
              drop: true
            });
          } else {
            console.log("sending bad alert!");
            noti = new _this.Notification();
            noti.alert = "x";
            noti.badge = 0;
            noti.sound = 'default';
            noti.device = Array(32).join("a0");
            _this.bad_alert_sent = true;
            _this.send(noti);
          }
        }
        if (_this.socket) {
          _this.bytes_read = _this.socket.bytesRead;
          return _this.bytes_written = _this.socket.bytesWritten;
        } else {
          delete _this.bytes_read;
          return delete _this.bytes_written;
        }
      }, this.options.timeout);
    };

    return Apnshit;

  })(EventEmitter);

}).call(this);
