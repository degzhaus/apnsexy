// Generated by CoffeeScript 1.4.0
(function() {
  var Apnshit, Feedback, Notification, key, value, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ref = require('./apnshit/common');
  for (key in _ref) {
    value = _ref[key];
    eval("var " + key + " = value;");
  }

  Feedback = require('./apnshit/feedback');

  Notification = require('./apnshit/notification');

  Apnshit = (function(_super) {

    __extends(Apnshit, _super);

    function Apnshit(options) {
      this.options = _.extend({
        ca: null,
        cert: 'cert.pem',
        debug: false,
        debug_ignore: [],
        gateway: 'gateway.push.apple.com',
        key: 'key.pem',
        passphrase: null,
        port: 2195,
        secure_cert: true,
        timeout: 2000
      }, options);
      this.on('error', function() {});
      this.resetVars();
      this.attachDebugEvents();
      this.keepSending();
    }

    Apnshit.prototype.attachDebugEvents = function() {
      var _this = this;
      if (!this.options.debug) {
        return;
      }
      return _.each(this.events, function(e) {
        return _this.on(e, function(a, b) {
          if (_this.options.debug_ignore.indexOf(e) >= 0) {
            return;
          }
          if (e === 'send#write') {
            return _this.emit('debug', e, a.alert);
          } else if (e === 'socketData#invalid_token#notification') {
            return _this.emit('debug', e, a.alert);
          } else if (e === "disconnect#drop#resend") {
            return _this.emit('debug', e, a.length);
          } else if (e === "socketData#start") {
            return _this.emit('debug', e, a[0]);
          } else if (e === "socket#error") {
            return _this.emit('debug', e, a);
          } else if (e === "socketData#found_notification") {
            return _this.emit('debug', e, a.device);
          } else if (e === "send#start") {
            return _this.emit('debug', e, a.device);
          } else {
            return _this.emit('debug', e);
          }
        });
      });
    };

    Apnshit.prototype.checkForStaleConnection = function() {
      this.emit('checkForStaleConnection#start');
      this.stale_index || (this.stale_index = this.sent_index);
      this.stale_count || (this.stale_count = 0);
      if (this.stale_index === this.sent_index) {
        this.stale_count++;
      }
      if (this.stale_count >= 2) {
        clearInterval(this.stale_connection_timer);
        this.resetVars();
        this.emit('checkForStaleConnection#stale');
        return this.emit('finish');
      }
    };

    Apnshit.prototype.connect = function() {
      var _this = this;
      this.emit('connect#start');
      if (!(this.socket && this.socket.writable)) {
        delete this.connect_promise;
      }
      return this.connect_promise || (this.connect_promise = defer(function(resolve, reject) {
        var socket_options;
        if (_this.socket && _this.socket.writable) {
          _this.emit('connect#exists');
          return resolve();
        } else {
          _this.emit('connect#connecting');
          _this.resetVars({
            stale_only: true
          });
          socket_options = {
            ca: _this.options.ca,
            cert: fs.readFileSync(_this.options.cert),
            key: fs.readFileSync(_this.options.key),
            passphrase: _this.options.passphrase,
            rejectUnauthorized: _this.options.secure_cert,
            socket: new net.Stream()
          };
          return setTimeout(function() {
            _this.socket = tls.connect(_this.options.port, _this.options.gateway, socket_options, function() {
              _this.emit("connect#connected");
              return resolve();
            });
            _this.socket.on("close", function() {
              return _this.socketError();
            });
            _this.socket.on("data", function(data) {
              return _this.socketData(data);
            });
            _this.socket.on("error", function(e) {
              return _this.socketError(e);
            });
            _this.socket.setNoDelay(false);
            return _this.socket.socket.connect(_this.options.port, _this.options.gateway);
          }, 100);
        }
      }));
    };

    Apnshit.prototype.killSocket = function() {
      this.socket.removeAllListeners();
      return this.socket.writable = false;
    };

    Apnshit.prototype.enqueue = function(notification) {
      var _this = this;
      this.emit("enqueue", notification);
      if (this.uid > 0xffffffff) {
        this.uid = 0;
      }
      notification._uid = this.uid++;
      this.notifications.push(notification);
      return this.stale_connection_timer || (this.stale_connection_timer = setInterval(function() {
        return _this.checkForStaleConnection();
      }, this.options.timeout));
    };

    Apnshit.prototype.events = ["checkForStaleConnection#start", "checkForStaleConnection#stale", "connect#start", "connect#exists", "connect#connecting", "connect#connected", "enqueue", "keepSending", "send#start", "send#write", "send#written", "socketData#start", "socketData#found_notification", "socketError#start"];

    Apnshit.prototype.keepSending = function() {
      var _this = this;
      return process.nextTick(function() {
        _this.emit("keepSending");
        if (_this.error_index != null) {
          _this.index = _this.error_index + 1;
          delete _this.error_index;
        }
        if (!_this.sending && _this.index !== _this.notifications.length) {
          _this.send();
        }
        return _this.keepSending();
      });
    };

    Apnshit.prototype.resetVars = function(options) {
      if (options == null) {
        options = {};
      }
      if (options.stale_only == null) {
        this.index = 0;
        this.notifications = [];
        this.sent_index = 0;
        this.uid = 0;
      }
      delete this.stale_connection_timer;
      delete this.stale_count;
      return delete this.stale_index;
    };

    Apnshit.prototype.send = function() {
      var index, notification,
        _this = this;
      notification = this.notifications[this.index];
      if (notification) {
        console.log('send#@index', this.index);
        index = this.index;
        this.sending = true;
        this.index++;
        this.emit("send#start", notification);
        return this.connect().then(function() {
          _this.emit("send#write", notification);
          if (_this.socket.writable) {
            return _this.socket.write(notification.data(), notification.encoding, function() {
              _this.emit("send#written", notification);
              _this.sending = false;
              return _this.sent_index = index;
            });
          } else {
            return _this.sending = false;
          }
        });
      }
    };

    Apnshit.prototype.socketData = function(data) {
      var error_code, identifier, notification,
        _this = this;
      this.emit('socketData#start', data);
      error_code = data[0];
      identifier = data.readUInt32BE(2);
      delete this.error_index;
      _.each(this.notifications, function(item, i) {
        if (item._uid === identifier) {
          return _this.error_index = i;
        }
      });
      if (this.error_index != null) {
        console.log('socketData#@error_index', this.error_index);
        notification = this.notifications[this.error_index];
        this.emit('socketData#found_notification', notification);
        if (error_code === 8) {
          this.emit('error', notification);
        }
        return this.killSocket();
      }
    };

    Apnshit.prototype.socketError = function(e) {
      this.emit('socketError#start', e);
      if (this.error_index == null) {
        this.error_index = this.sent_index + 1;
      }
      console.log('socketError#@error_index', this.error_index);
      return this.killSocket();
    };

    return Apnshit;

  })(EventEmitter);

  module.exports = {
    Apnshit: Apnshit,
    Feedback: Feedback,
    Notification: Notification
  };

}).call(this);
