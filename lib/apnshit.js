// Generated by CoffeeScript 1.4.0
(function() {
  var Apnshit, Feedback, Notification, key, value, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ref = require('./apnshit/common');
  for (key in _ref) {
    value = _ref[key];
    eval("var " + key + " = value;");
  }

  Feedback = require('./apnshit/feedback');

  Notification = require('./apnshit/notification');

  Apnshit = (function(_super) {

    __extends(Apnshit, _super);

    function Apnshit(options) {
      this.current_id = 0;
      this.notifications = [];
      this.sent = [];
      this.options = {
        ca: null,
        cert: 'cert.pem',
        debug: false,
        debug_ignore: [],
        enhanced: true,
        gateway: 'gateway.push.apple.com',
        infinite_resend_limit: 10,
        key: 'key.pem',
        passphrase: null,
        port: 2195,
        reject_unauthorized: true,
        timeout: 5000
      };
      _.extend(this.options, options);
      this.on('error', function() {});
      if (this.options.debug) {
        this.attachDebugEvents();
      }
      this.keepSending();
    }

    Apnshit.prototype.attachDebugEvents = function() {
      var _this = this;
      return _.each(this.events, function(e) {
        return _this.on(e, function(a, b) {
          if (_this.options.debug_ignore.indexOf(e) >= 0) {
            return;
          }
          if (e === 'send#write') {
            return _this.emit('debug', e, a.alert);
          } else if (e === 'socketData#invalid_token#notification') {
            return _this.emit('debug', e, a.alert);
          } else if (e === "disconnect#drop#resend") {
            return _this.emit('debug', e, a.length);
          } else if (e === "socketData#start") {
            return _this.emit('debug', e, a[0]);
          } else if (e === "socket#error") {
            return _this.emit('debug', e, a);
          } else {
            return _this.emit('debug', e);
          }
        });
      });
    };

    Apnshit.prototype.checkForStaleConnection = function() {
      var stale;
      this.emit('checkForStaleConnection#start');
      if (this.socket) {
        stale = this.socket.socket.bytesRead === this.bytes_read && this.socket.socket.bytesWritten === this.bytes_written;
        this.stale_count || (this.stale_count = 0);
        this.stale_count++;
        if (this.stale_count === 2) {
          clearInterval(this.stale_connection_timer);
          delete this.stale_connection_timer;
          delete this.stale_count;
          this.emit('checkForStaleConnection#stale');
          this.emit('finish');
        }
        this.bytes_read = this.socket.socket.bytesRead;
        return this.bytes_written = this.socket.socket.bytesWritten;
      }
    };

    Apnshit.prototype.connect = function() {
      var _this = this;
      this.emit('connect#start');
      if (!(this.socket && this.socket.writable)) {
        delete this.connect_promise;
      }
      return this.connect_promise || (this.connect_promise = defer(function(resolve, reject) {
        var socket_options;
        if (_this.socket && _this.socket.writable) {
          _this.emit('connect#exists');
          return resolve();
        } else {
          _this.emit('connect#connecting');
          _this.stale_connection_timer || (_this.stale_connection_timer = setInterval(function() {
            return _this.checkForStaleConnection();
          }, Math.floor(_this.options.timeout / 2)));
          delete _this.bytes_read;
          delete _this.bytes_written;
          delete _this.stale_count;
          socket_options = {
            ca: _this.options.ca,
            cert: fs.readFileSync(_this.options.cert),
            key: fs.readFileSync(_this.options.key),
            passphrase: _this.options.passphrase,
            rejectUnauthorized: _this.options.reject_unauthorized,
            socket: new net.Stream()
          };
          return setTimeout(function() {
            _this.socket = tls.connect(_this.options.port, _this.options.gateway, socket_options, function() {
              _this.emit("connect#connected");
              return resolve();
            });
            _this.socket.on("close", function() {
              return _this.socketError();
            });
            _this.socket.on("data", function(data) {
              return _this.socketData(data);
            });
            _this.socket.on("error", function(e) {
              return _this.socketError(e);
            });
            _this.socket.setNoDelay(false);
            return _this.socket.socket.connect(_this.options.port, _this.options.gateway);
          }, 100);
        }
      }));
    };

    Apnshit.prototype.enqueue = function(notification) {
      this.emit("enqueue", notification);
      if (this.current_id > 0xffffffff) {
        this.current_id = 0;
      }
      notification._uid = this.current_id++;
      return this.notifications.push(notification);
    };

    Apnshit.prototype.events = ["checkForStaleConnection#start", "checkForStaleConnection#stale", "connect#start", "connect#exists", "connect#connecting", "connect#connected", "enqueue", "keepSending", "send#start", "send#write", "send#written", "socketData#start", "socketData#found_notification", "socketError#start"];

    Apnshit.prototype.keepSending = function() {
      var _this = this;
      return process.nextTick(function() {
        _this.emit("keepSending");
        if (!_this.sending && _this.notifications.length) {
          _this.send();
        }
        return _this.keepSending();
      });
    };

    Apnshit.prototype.send = function() {
      var data, encoding, message, message_length, notification, position, token,
        _this = this;
      notification = this.notifications.shift();
      if (notification) {
        this.sending = true;
        this.emit("send#start", notification);
        data = void 0;
        encoding = notification.encoding || "utf8";
        message = JSON.stringify(notification);
        message_length = Buffer.byteLength(message, encoding);
        position = 0;
        token = new Buffer(notification.device.replace(/\s/g, ""), "hex");
        if (this.options.enhanced) {
          data = new Buffer(1 + 4 + 4 + 2 + token.length + 2 + message_length);
          data[position] = 1;
          position++;
          data.writeUInt32BE(notification._uid, position);
          position += 4;
          data.writeUInt32BE(notification.expiry, position);
          position += 4;
        } else {
          data = new Buffer(1 + 2 + token.length + 2 + message_length);
          data[position] = 0;
          position++;
        }
        data.writeUInt16BE(token.length, position);
        position += 2;
        position += token.copy(data, position, 0);
        data.writeUInt16BE(message_length, position);
        position += 2;
        position += data.write(message, position, encoding);
        return this.connect().then(function() {
          _this.emit("send#write", notification);
          _this.sent.push(notification);
          if (_this.socket.writable) {
            return _this.socket.write(data, encoding, function() {
              _this.emit("send#written", notification);
              _this.sending = false;
              return notification._written = true;
            });
          } else {
            _this.notifications.unshift(notification);
            _this.sent = _.reject(_this.sent, function(n) {
              return n._uid === notification._uid;
            });
            return _this.sending = false;
          }
        });
      }
    };

    Apnshit.prototype.socketData = function(data) {
      var error_code, identifier, notification,
        _this = this;
      this.emit('socketData#start', data);
      error_code = data[0];
      identifier = data.readUInt32BE(2);
      notification = _.find(this.sent, function(item, i) {
        return item._uid === identifier;
      });
      if (notification) {
        this.emit('socketData#found_notification', notification);
        if (error_code === 8) {
          this.emit('error', notification);
        }
        this.notifications = this.notifications.concat(this.sent.slice(this.sent.indexOf(notification) + 1));
        console.log('@notifications', this.notifications.length);
        _.each(this.notifications, function(n) {
          return delete n._written;
        });
        this.sent = [];
        return this.socket.writable = false;
      }
    };

    Apnshit.prototype.socketError = function(e) {
      var _this = this;
      this.emit('socketError#start', e);
      this.notifications = this.notifications.concat(_.reject(this.sent, function(n) {
        return n._written;
      }));
      return this.socket.writable = false;
    };

    return Apnshit;

  })(EventEmitter);

  module.exports = {
    Apnshit: Apnshit,
    Feedback: Feedback,
    Notification: Notification
  };

}).call(this);
