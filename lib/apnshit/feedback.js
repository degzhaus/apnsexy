// Generated by CoffeeScript 1.4.0
(function() {
  var Feedback, key, value, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ref = require('./common');
  for (key in _ref) {
    value = _ref[key];
    eval("var " + key + " = value;");
  }

  module.exports = Feedback = (function(_super) {

    __extends(Feedback, _super);

    function Feedback(options) {
      this.startInterval = __bind(this.startInterval, this);

      var _this = this;
      this.on("error", function() {});
      this.options = {
        address: "feedback.push.apple.com",
        ca: null,
        cert: "cert.pem",
        debug: false,
        debug_ignore: [],
        interval: 60,
        key: "key.pem",
        passphrase: null,
        port: 2196,
        reject_unauthorized: true
      };
      _.extend(this.options, options);
      if (this.options.debug) {
        _.each(this.events, function(e) {
          return _this.on(e, function(a, b) {
            if (_this.options.debug_ignore.indexOf(e) >= 0) {
              return;
            }
            return _this.emit('debug', e);
          });
        });
      }
      this.connect().then(function() {
        return _this.startInterval();
      });
    }

    Feedback.prototype.connect = function() {
      var _this = this;
      this.emit('connect#start', this.connect_promise);
      return this.connect_promise || (this.connect_promise = defer(function(resolve, reject) {
        var socket_options;
        if (_this.socket && _this.socket.writable) {
          _this.emit('connect#exists');
          return resolve();
        } else {
          _this.emit('connect#connecting');
          _this.connecting = true;
          socket_options = {
            ca: _this.options.ca,
            cert: fs.readFileSync(_this.options.cert),
            key: fs.readFileSync(_this.options.key),
            passphrase: _this.options.passphrase,
            rejectUnauthorized: _this.options.reject_unauthorized
          };
          _this.socket = tls.connect(_this.options.port, _this.options.address, socket_options, function() {
            _this.emit("connect#connected");
            resolve();
            return delete _this.connect_promise;
          });
          _this.read_buffer = new Buffer(0);
          _this.socket.on("data", function(data) {
            return _this.socketData(data);
          });
          return _this.socket.on("error", function(e) {
            _this.emit("socket#error", e);
            return _this.disconnect({
              drop: true
            });
          });
        }
      }));
    };

    Feedback.prototype.events = ['connect#start', 'connect#exists', 'connect#connecting', 'connect#connected', 'disconnect#start', 'disconnect#drop', 'disconnect#finish', 'socket#error', 'socketData#start', 'socketData#received_packet', 'socketData#parsed_token', 'startInterval#start', 'startInterval#interval_start'];

    Feedback.prototype.disconnect = function(options) {
      var _this = this;
      if (options == null) {
        options = {};
      }
      this.emit("disconnect#start", options);
      delete this.connect_promise;
      this.socket.destroy();
      delete this.socket;
      if (this.interval) {
        clearInterval(this.interval);
      }
      if (options.drop) {
        this.emit("disconnect#drop");
        return this.connect().then(function() {
          return _this.startInterval();
        });
      } else {
        this.emit("disconnect#finish");
        return this.emit("finish");
      }
    };

    Feedback.prototype.socketData = function(data) {
      var new_buffer, time, token, token_length;
      this.emit('socketData#start', data);
      time = 0;
      token_length = 0;
      token = null;
      this.emit('socketData#received_packet', data);
      new_buffer = new Buffer(this.read_buffer.length + data.length);
      this.read_buffer.copy(new_buffer);
      data.copy(new_buffer, this.read_buffer.length);
      this.read_buffer = new_buffer;
      while (this.read_buffer.length > 6) {
        time = this.read_buffer.readUInt32BE(0);
        token_length = this.read_buffer.readUInt16BE(4);
        if ((this.read_buffer.length - 6) < token_length) {
          return;
        }
        token = new Buffer(token_length);
        this.read_buffer.copy(token, 0, 6, 6 + token_length);
        token = token.toString("hex");
        this.emit('socketData#parsed_token', time, token);
        this.emit('feedback', time, token);
        this.read_buffer = this.read_buffer.slice(6 + token_length);
      }
    };

    Feedback.prototype.startInterval = function() {
      var _this = this;
      this.emit('startInterval#start');
      if (this.interval) {
        clearInterval(this.interval);
      }
      return this.interval = setInterval(function() {
        _this.emit('startInterval#interval_start');
        if (_this.socket && !_this.socket.writable) {
          return _this.disconnect({
            drop: true
          });
        }
      }, this.options.interval * 1000);
    };

    return Feedback;

  })(EventEmitter);

}).call(this);
